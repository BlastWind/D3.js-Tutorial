D3's force directed graph allows us use an array of objects like:
[
  { name: "Alice" },
  { name: "Bob" },
  { name: "Chen" },
  { name: "Dawg" },
  { name: "Ethan" },
  { name: "George" },
  { name: "Frank" },
  { name: "Hanes" }
]
And when you run simulation = d3.forceSimulation(your_array), the simulation
will automatically start ticking (in v4, maybe not in v3), which will give the
objects in your array attributes like: x, y, vx (velocity of your particle), vy,
etc...
In other words, your array will be modified to
[
  { name: "Alice", x:..., y:..., vx: ..., ... },
  { name: "Bob", x:..., y:..., vx:..., ... },
  { name: "Chen", x:..., y:..., vx:..., ... },
  ...
]
These attributes will continuously update, it stops when the alpha value of
forcesimulation reaches 0

So now we have this array of objects with positions generated by the
forcesimulation, let's actually draw them:

var node = svg
  .append("g")
  .attr("class", "nodes")
  .selectAll("circle")
  .data(graph.nodes)
  .enter()
  .append("circle")
  .attr("r", 5)
  .attr("fill", function(d) {
    return "red";
  })

That is only the initial render, we want to continously update their position,
and logically, the only place to update these are inside of tick() because
every time tick() calls a new position is calculated:

function ticked() {
  link
    .attr("x1", function(d) {
      return d.source.x;
    })
    .attr("y1", function(d) {
      return d.source.y;
    })
    .attr("x2", function(d) {
      return d.target.x;
    })
    .attr("y2", function(d) {
      return d.target.y;
    });

  node
    .attr("cx", function(d) {
      return d.x;
    })
    .attr("cy", function(d) {
      return d.y;
    });
}

Good luck on your d3.js journey :)
